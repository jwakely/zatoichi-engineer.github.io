---
layout: post
title: "Seccomp and Its Performance Impact"
date: 2017-10-06
---
Effective software security is best done in layers; if an attacker is able
to penetrate one layer they encounter another. An attack strategy becoming
more common is to attack the kernel itself; if one succeeds in injecting
code into kernel space it is game over.

As an example of this, Ang Cui and Salvatore Solfo from Columbia University
discovered
(vulnerabilities in Cisco phones)[https://arstechnica.com/information-technology/2013/01/hack-turns-the-cisco-phone-on-your-desk-into-a-remote-bugging-device/]
which allowed them to inject arbitrary code into kernel memory. They discovered
the necessary vulnerabilities by fuzzing the kernel by way of fuzzing
system calls.

Not all processes in a system need to be able to make all possible system calls.
Limiting the system calls possible reduces the kernel's attack surface, making
issue much less likely. In addition, limiting system call usage will also
limit the damage an attacker can do if a vulnerability is exploited in
user-land code.






https://outflux.net/teach-seccomp/




{% highlight c %}
diff --git a/ffmpeg.c b/ffmpeg.c
index b26995d..e46a2c2 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -4298,11 +4298,120 @@ static void log_callback_null(void *ptr, int level, const char *fmt, va_list vl)
 {
 }

+#include <sys/prctl.h>
+#ifndef PR_SET_NO_NEW_PRIVS
+# define PR_SET_NO_NEW_PRIVS 38
+#endif
+
+#include <linux/unistd.h>
+#include <linux/audit.h>
+#include <linux/filter.h>
+#ifdef HAVE_LINUX_SECCOMP_H
+# include <linux/seccomp.h>
+#endif
+#ifndef SECCOMP_MODE_FILTER
+# define SECCOMP_MODE_FILTER   2 /* uses user-supplied filter. */
+# define SECCOMP_RET_KILL      0x00000000U /* kill the task immediately */
+# define SECCOMP_RET_TRAP      0x00030000U /* disallow and force a SIGSYS */
+# define SECCOMP_RET_ALLOW     0x7fff0000U /* allow */
+struct seccomp_data {
+    int nr;
+    __u32 arch;
+    __u64 instruction_pointer;
+    __u64 args[6];
+};
+#endif
+#ifndef SYS_SECCOMP
+# define SYS_SECCOMP 1
+#endif
+
+#define syscall_nr (offsetof(struct seccomp_data, nr))
+#define arch_nr (offsetof(struct seccomp_data, arch))
+
+#if defined(__i386__)
+# define REG_SYSCALL   REG_EAX
+# define ARCH_NR       AUDIT_ARCH_I386
+#elif defined(__x86_64__)
+# define REG_SYSCALL   REG_RAX
+# define ARCH_NR       AUDIT_ARCH_X86_64
+#else
+# warning "Platform does not support seccomp filter yet"
+# define REG_SYSCALL   0
+# define ARCH_NR       0
+#endif
+
+#define VALIDATE_ARCHITECTURE \
+       BPF_STMT(BPF_LD+BPF_W+BPF_ABS, arch_nr), \
+       BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ARCH_NR, 1, 0), \
+       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL)
+
+#define EXAMINE_SYSCALL \
+       BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr)
+
+#define ALLOW_SYSCALL(name) \
+       BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_##name, 0, 1), \
+       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)
+
+#define KILL_PROCESS \
+       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL)
+
+static void install_syscall_filter()
+{
+   struct sock_filter filter[] = {
+      /* Validate architecture. */
+      VALIDATE_ARCHITECTURE,
+      /* Grab the system call number. */
+      EXAMINE_SYSCALL,
+      /* List allowed syscalls. */
+      ALLOW_SYSCALL(rt_sigreturn),
+#ifdef __NR_sigreturn
+      ALLOW_SYSCALL(sigreturn),
+#endif
+      ALLOW_SYSCALL(exit_group),
+      ALLOW_SYSCALL(exit),
+      ALLOW_SYSCALL(open),
+      ALLOW_SYSCALL(close),
+      ALLOW_SYSCALL(read),
+      ALLOW_SYSCALL(write),
+      ALLOW_SYSCALL(ioctl),
+      ALLOW_SYSCALL(brk),
+      ALLOW_SYSCALL(rt_sigaction),
+      ALLOW_SYSCALL(fcntl64),
+      ALLOW_SYSCALL(fstat64),
+      ALLOW_SYSCALL(_llseek),
+      ALLOW_SYSCALL(mmap2),
+      ALLOW_SYSCALL(munmap),
+      ALLOW_SYSCALL(mremap),
+      ALLOW_SYSCALL(futex),
+      ALLOW_SYSCALL(getrusage),
+      ALLOW_SYSCALL(time),
+      ALLOW_SYSCALL(sched_getaffinity),
+      ALLOW_SYSCALL(_newselect),
+      ALLOW_SYSCALL(clock_gettime),
+      KILL_PROCESS,
+   };
+   struct sock_fprog prog = {
+      .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
+      .filter = filter,
+   };
+
+   if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
+      perror("prctl(NO_NEW_PRIVS)");
+      exit(1);
+   }
+   if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {
+      perror("prctl(SECCOMP)");
+      exit(1);
+   }
+}
+
 int main(int argc, char **argv)
 {
     int ret;
     int64_t ti;

+    install_syscall_filter();
+
     init_dynload();

     register_exit(ffmpeg_cleanup);
{% endhighlight %}




Additional experiment attempted the following 100,000 times:

{% highlight c %}
int fd = open("/dev/zero", O_RDONLY);
char data;
read(fd, &data, sizeof(data));
close(fd);
{% endhighlight %}

octave:14> mean(seccomp)-mean(base)
ans =  0.58460
octave:15> (mean(seccomp)-mean(base))/100000
ans =    5.8460e-06
octave:16> (mean(seccomp)/mean(base))/mean(base)
ans =  0.44545
